import HelpfulIterator from './HelpfulIterator';
import LazyIterator from './LazyIterator';
/**
 * A lazy iterator (see `LazyIterator`) which comes up with an educated guess for the amount of values which have to be
 * produced to meet the demand.
 *
 * Take this example:
 * ```
 * await […].iterate().drop(5).take(10).forEach([…]);
 * ```
 * In this scenario, this class would correctly guess that the iterator only has to produce 15 values to meet the
 * demand. The upstream iterator can take advantage of this information to avoid preparing values which will never be
 * consumed.
 *
 * Because any number of new iterators can be created from any iterator (through `drop`, `filter`, `map`, and `take`),
 * those iterators together form a (rooted) tree. The educated guess is derived from the path between the root and the
 * leaf which triggers the creation of the upstream iterator.
 *
 * This does mean that in the following example, this class incorrectly guesses that only 10 values are required when
 * in actuality 12 are required:
 * ```
 * const iterator = […].iterate();
 * await iterator.take(10).forEach([…]);
 * await iterator.take(2).forEach([…]);
 * ```
 */
export default class DemandingIterator<T> extends LazyIterator<T> {
    private path;
    constructor(create: (demand: number) => HelpfulIterator<T>);
    constructor(create: () => HelpfulIterator<T>, path: Array<(demand: number) => number>);
    drop(limit: number): DemandingIterator<T>;
    filter(callback: (value: T) => boolean | Promise<boolean>): DemandingIterator<T>;
    map<U>(callback: (value: T) => U | Promise<U>): DemandingIterator<U>;
    take(limit: number): DemandingIterator<T>;
}
